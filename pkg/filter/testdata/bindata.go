package testdata

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"strings"
)

func bindata_read(data []byte, name string) ([]byte, error) {
	gz, err := gzip.NewReader(bytes.NewBuffer(data))
	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	var buf bytes.Buffer
	_, err = io.Copy(&buf, gz)
	gz.Close()

	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	return buf.Bytes(), nil
}

var _filter_flat_json = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xbc\x56\xcd\x6f\x9b\x30\x14\xbf\xe7\xaf\xb0\x7c\xc6\xd2\xb3\x81\xf0\x71\xeb\x56\x54\x75\xeb\x50\xb6\x20\x4d\x5b\x95\x83\xf1\x47\x63\x29\x09\x15\x71\x7b\x99\xf2\xbf\x4f\x40\xda\x26\x6d\xa8\x49\xd6\xe5\x04\xf6\x7b\xfe\x7d\x21\xf9\xf1\x67\x84\x10\xbe\xe7\x77\x66\x75\x87\x53\xd4\xac\xba\xb5\xc2\x29\xa2\x5e\xb7\x34\x56\x2d\xd7\x13\x55\x4f\xba\x6d\x06\x23\x84\x36\x4d\x0d\xaf\xab\xda\xaa\x1a\xa7\xe8\xb6\xed\xec\x8e\x23\x84\x45\xb5\x78\x58\xae\x70\x8a\xb0\x36\xf5\xda\xe6\x7c\xa9\xb0\xf7\x54\x94\xa6\x56\xc2\x9a\xaa\xad\x5f\x4c\x3f\xe3\xb6\xb0\xf1\xfa\x20\x44\xad\xb8\x55\xb2\x07\xe0\x32\x73\x23\x18\xb9\xed\x18\x21\x34\xeb\x84\x2b\x5e\x8b\x79\x53\x7b\xe4\x8b\x87\x4e\x1c\xd6\x66\xb1\xeb\xe6\x76\x0b\xf4\x04\xf8\x1a\xd2\x7b\xd9\xaf\xee\x55\xcd\x6d\xd5\x9c\xc5\xd9\xf7\xdd\x4a\x07\x9f\x3e\x83\xb5\x9b\x9a\x8e\x29\x0d\xc2\x80\x48\x55\x96\x24\x90\x89\x26\xa5\x8c\x62\x12\xfb\x1a\xa4\x1f\x97\x40\xa3\x31\x7e\x3e\x30\xdb\xbe\x6d\xbc\xd3\x04\xe5\x03\x14\xc5\xa1\x3f\x0e\x12\x11\x91\x44\xeb\x84\x04\x61\xc4\x48\x19\x96\x8c\x24\xb1\x8e\x25\xf7\x41\x31\xe0\x3b\x20\x08\xe1\xa0\x64\x91\x14\x71\x44\x54\x32\x4e\x48\x50\x0a\x9f\x70\x2d\x42\x42\x93\x30\x00\x5f\x2b\x1e\xc6\x70\xc0\x43\xfb\x9c\x79\xee\x80\x5f\xbe\xcb\x01\x4b\x57\x85\xcb\x11\x85\x23\xf3\x7b\x97\xef\xa6\xc8\x4e\x21\xfc\x18\xb3\x37\x4e\xb3\x98\x1e\x8a\xfa\x74\xbb\x57\x6e\xbb\x87\x29\x07\x1b\x5e\xed\xde\x08\xaf\xfd\x5e\x7f\x75\xd3\x7f\xa9\xe6\x2b\x34\x5d\x1a\x3b\xff\x5f\x32\xa6\xc5\xc5\x8f\x62\x3a\x48\xc8\xb1\xe1\xbf\x47\x9b\xe5\x97\x6e\xd2\x7f\x36\xce\x85\x35\x8f\xcd\xad\x7a\x61\x9d\x64\x0c\x80\x11\x0a\x04\x58\x41\xc3\x14\x20\x05\xf8\x7d\xac\xe3\x1e\xbe\x3d\xe3\xdf\x26\xc5\x2f\xfc\x51\x68\xf9\x3e\xdc\xe0\x60\xb6\xc3\xa6\x1f\xf8\x53\x56\xfc\xcc\xb2\x7c\x48\x6a\xf0\x26\x35\x6f\xbf\x83\xbd\xed\x38\x32\x57\xa7\xdc\xfc\xec\x7a\x07\x47\xdd\x3f\xb1\xae\xdd\x72\xcf\x3c\x42\x07\x28\x3a\xf3\x08\x6d\x7e\x65\x46\x9b\xbf\x01\x00\x00\xff\xff\x98\xdd\xd9\x35\xbf\x09\x00\x00")

func filter_flat_json() ([]byte, error) {
	return bindata_read(
		_filter_flat_json,
		"filter_flat.json",
	)
}

var _filter_nested_json = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xbc\x56\x5b\x6f\xda\x30\x14\x7e\xe7\x57\x58\x7e\x8e\x2b\xdb\x49\xc8\xe5\x8d\xad\x51\xd5\xad\x8b\xd8\x88\x34\x6d\x15\x0f\x8e\x2f\xc5\x12\x90\x2a\xb8\xd5\xa4\x89\xff\x3e\x25\xa1\x2d\x8c\xa4\x4e\x5a\xca\x13\xd8\xe7\xf8\xbb\x59\xf8\xf0\x77\x04\x00\xbc\x67\x77\x7a\x7d\x07\x63\x50\xad\x9a\xb5\x84\x31\x20\x4e\xb3\xd4\x46\xae\x36\x53\x59\x4e\x9b\x6d\x8a\x47\x00\x6c\xab\x1a\xdc\x14\xa5\x91\x25\x8c\xc1\x6d\xdd\xd9\x1c\x07\x00\xf2\x62\xf9\xb0\x5a\xc3\x18\x40\xa5\xcb\x8d\x49\xd9\x4a\x42\xe7\xa9\x28\x74\x29\xb9\xd1\x45\x5d\x9f\xcc\x3e\xc3\xba\xb0\x75\xba\x20\x78\x29\x99\x91\xa2\x03\xe0\x32\xb1\x23\xfc\xb9\xd0\x62\xd7\x33\x02\x60\xde\x48\x97\xac\xe4\x8b\xaa\xfa\xc8\x96\x0f\x8d\x3c\xa8\xf4\x72\xdf\xcf\xed\x0e\xea\x09\xf2\x18\xd4\x79\xa9\x14\xf7\xb2\x64\xa6\xa8\x4e\xc3\xe4\xfb\x7e\xa5\x21\x88\x9f\xe1\xea\x4d\x45\xc6\x84\x78\xbe\x87\x84\xcc\x73\xe4\x89\x48\xa1\x5c\x04\x21\x0a\x5d\x85\x85\x1b\xe6\x98\x04\x63\xf8\x7c\x60\xbe\xfb\xb6\x75\xde\x2a\x29\xed\xa1\x29\xf4\xdd\xb1\x17\xf1\x00\x45\x4a\x45\xc8\xf3\x03\x8a\x72\x3f\xa7\x28\x0a\x55\x28\x98\x8b\x25\xc5\x6c\x0f\x04\x00\xe8\xe5\x34\x10\x3c\x0c\x90\x8c\xc6\x11\xf2\x72\xee\x22\xa6\xb8\x8f\x48\xe4\x7b\xd8\x55\x92\xf9\x21\x6e\x71\x51\x7f\xce\x9d\x3e\x21\xbf\xdc\x4e\x8b\xa9\xab\xcc\xe6\x89\xe0\xc1\x19\xbe\xca\x78\x93\x25\x6f\xa1\x3c\x95\xe1\x1b\xab\x61\x48\xda\x02\x7f\x8f\xe5\x2b\xbb\xe5\x76\xd2\x01\xa6\xd7\xfb\x2f\xc4\xff\x9e\xaf\xbf\xda\x05\x7c\x29\x16\x6b\x30\x5b\x69\xb3\xf8\x38\x21\xb3\x6c\xf2\x23\x9b\xf5\x92\x32\xfc\x0a\x5e\x23\x4e\xd2\x4b\x3b\xed\xbb\xcd\x6f\x2e\x18\x37\xfa\xb1\x7a\x6b\x27\xc6\x4a\x47\x31\xa6\x88\x60\x84\x69\x46\xfc\x18\xe3\x18\xe3\xdf\x43\x5d\x77\x32\x1e\x98\xff\x36\xcd\x7e\xc1\xd3\xe1\xa5\x87\x80\x03\xe2\xd9\x0d\xa2\x6e\xe8\x4f\x49\xf6\x33\x49\xd2\x3e\xd9\xe1\xa3\xec\x9c\xc3\x0e\x7a\xdc\x31\x38\x5d\xab\xe0\xf4\xec\x8a\x07\xfc\x14\xbb\x67\xd9\xb5\x5d\xf0\xd9\xc7\x6b\x0f\x4d\x67\x1e\xaf\xd5\x5f\x9d\xd1\xf6\x5f\x00\x00\x00\xff\xff\x7d\x2e\xc4\x6f\xe1\x09\x00\x00")

func filter_nested_json() ([]byte, error) {
	return bindata_read(
		_filter_nested_json,
		"filter_nested.json",
	)
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		return f()
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() ([]byte, error){
	"filter_flat.json":   filter_flat_json,
	"filter_nested.json": filter_nested_json,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for name := range node.Children {
		rv = append(rv, name)
	}
	return rv, nil
}

type _bintree_t struct {
	Func     func() ([]byte, error)
	Children map[string]*_bintree_t
}

var _bintree = &_bintree_t{nil, map[string]*_bintree_t{
	"filter_flat.json":   &_bintree_t{filter_flat_json, map[string]*_bintree_t{}},
	"filter_nested.json": &_bintree_t{filter_nested_json, map[string]*_bintree_t{}},
}}
